# 参考文章
1 [Java HashMap详解：源码分析、hash 原理、扩容机制、加载因子、线程不安全](https://javabetter.cn/collection/hashmap.html)

2 [Intellij IDEA 设置JDK版本](https://www.cnblogs.com/east7/p/13337630.html)

3 [IDEA中 java: 警告: 源发行版 11 需要目标发行版 11解决](https://blog.csdn.net/weixin_53573372/article/details/118875386)
# 1 运算
## 1.1 取模、取余运算
在数学或算术中，取模、取余运算被用来描述当一个数除以另一个数后所得的剩余部分。

在 Java 中，通常使用 % 运算符来表示取余，用 Math.floorMod() 来表示取模。

不同之处：

取余操作结果的符号与被除数的符号相同。比如 -7 % 3 = -1。
取模操作结果的符号与除数的符号相同。比如 Math.floorMod(-7, 3) = 2。

01、取余：

在Java中，当我们使用 % 运算符时，得到的是余数。余数的定义是基于常规除法的，所以它的符号总是与被除数相同。

例如，对于 -7 % 3，余数是 -1。为什么？

因为用3去除-7，可以得到商-2和余数-1，因为 (-7 = 3 × (-2) - 1)。

02、取模：

取模的行为与取余类似，但关键的区别在于它是如何处理负数的。Math.floorMod 的工作原理是：在执行除法时，
商，会向下取整到最接近的整数。

例如，对于 Math.floorMod(-7, 3)，结果是 2。为什么？

这里的关键是“向下取整”。当我们将-7除以3时，商是-2.33。向下取整意味着向负无穷方向取整，所以商是-3。余数是2，
因为 (-7 = 3 × (-3) + 2)。

这种区别主要是如何处理商的小数部分。在取余操作中，我们只是简单地丢弃小数部分，所以-7除以3的商是-2。而在取模操作中，
我们向下取整，所以-7除以3的商是-3。

HashMap中再存取元素的时候会根据key优化后的hash值和数组的长度进行取模运算，其形式为 hash & (n -1)

# 2 HashMap的分析
## 2.1 hash方法的原理
在调用HashMap#put(K, V)的时候，会首先调用hash(K)。

hash方法的实现思路是先获取对象key的HashCode的值，将HashCode的值二进制数右移16位得到新的二进制数，然后和原
HashCode的值进行异或运算，得到新的hash值。混合了原hash值的高位和地位，增加了随机线性，让元素能均匀地分布，
减少碰撞。

为什么要进行异或运算，因为对于HashCode的高位和低位的分布是比较均匀的，如果只是进行简单的将它们加起来或者进行
位运算，容易出现哈希冲突，而异或运算可以避免这个问题。

然后将得到和hash值与HashMap中table的长度 -1 进行取模运算，得到键值对在数组中的索引，这个取模的操作将hash
值映射到桶在数组中的索引，桶是HashMap维护的数组中的元素，桶维护一个链表（或红黑树），存储了键值对。

对于int类型的数a和b，如果b是2的n次方，则有如下的规律：
a%b = a&(b-1)
## 2.2 HashMap的扩容原理
### 2.2.1 jdk 7 和 jdk 8的不同
扩容的过程中，会重新散列元素，针对元素在数组中的索引，jdk 7 会重新计算hash值，而jdk 8不会重新计算hash。
jdk 7 采用了单链表头部插入的方式拷贝元素，同一个桶新放置的元素位于链表的头部，这样改变了元素在旧数组同一个链表
上元素的顺序；jdk 8 则不是，jdk 8 定义了一个head，记录了旧数组中链表的头部元素，
且该元素的链表保证了原数组同一个链表中元素的顺序。

在添加元素的时候，如果元素发生了hash碰撞，jdk 7 上桶是以链表结构实现的，而jdk 8，桶的链表如果元素个数超过了8个，
则桶的链表结构转化为红黑树。

### 2.2.2 小结
HashMap的内部是通过一个数组和链表或红黑树的组合实现的。当向HashMap中不断添加元素时，如果元素的数量达到数组容量
乘以负载因子，就会自动扩容，扩容的大小为原来的两倍，以保证存储的元素数量不超过数组的容量限制。下面是HashMap的
扩容原理：
    
(1) HashMap会将数组的容量扩大一倍，然后将原来的元素重新散列到新的数组中，由于元素的散列位置是通过Key的hash值和
数组长度取模得到的，因此在数组容量扩大后，元素的散列位置也会发生一些改变。

(2) 在重新散列元素时，jdk7和jdk8 有不同，首先确定元素在新数组中的索引，jdk 7 会重新计算hash值，而jdk 8不会。
其实在确定元素在新数组桶中的位置，jdk7采用了单链表头部插入的方式，同一个桶新放置的元素位于链表的头部，这样改变了
元素在旧数组同一个链表上元素的顺序；jdk 8 则不是，如果桶中已经有了元素，那么元素就会被添加到链表的末尾，
如果链表的长度超过了8个，那么桶就会转化为红黑树。

总之，HashMap的扩容机制是通过扩大数组的容量和重新散列元素来实现的，它可以保证HashMap的存储容量足够大，同时也保证
了HashMap的存储效率和检索效率。但是，由于扩容需要耗费一定的时间和空间，因此在使用HashMap的时候，合理地设置初始
数组容量和加载因子，以避免过多的扩容操作。

## 2.3 加载因子为什么是0.75
如果负载因子过大，那么会出现较多的元素存储在少数的桶中，导致了冲突的增加，导致添加、删除的效率降低。如果负载因子过小
，会导致在添加元素的时候更频繁的扩容，这会时效率降低，扩容后的桶数量多了，但是桶的利用率变小了，空间上开销大。总之
0.75是平衡了时间和空间上的消耗，保证了哈希表的性能表现和空间利用。