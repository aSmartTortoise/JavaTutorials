# 参考文章
1 [Java HashMap详解：源码分析、hash 原理、扩容机制、加载因子、线程不安全](https://javabetter.cn/collection/hashmap.html)

2 [Intellij IDEA 设置JDK版本](https://www.cnblogs.com/east7/p/13337630.html)

3 [IDEA中 java: 警告: 源发行版 11 需要目标发行版 11解决](https://blog.csdn.net/weixin_53573372/article/details/118875386)
4 [【JAVA】HashMap的负载因子为什么是0.75](https://segmentfault.com/a/1190000023308658)
# 1 运算
## 1.1 取模、取余运算
在数学或算术中，取模、取余运算被用来描述当一个数除以另一个数后所得的剩余部分。

在 Java 中，通常使用 % 运算符来表示取余，用 Math.floorMod() 来表示取模。

不同之处：

取余操作结果的符号与被除数的符号相同。比如 -7 % 3 = -1。
取模操作结果的符号与除数的符号相同。比如 Math.floorMod(-7, 3) = 2。

1、取余：

在Java中，当我们使用 % 运算符时，得到的是余数。余数的定义是基于常规除法的，所以它的符号总是与被除数相同。

例如，对于 -7 % 3，余数是 -1。为什么？

因为用3去除-7，可以得到商-2和余数-1，因为 (-7 = 3 × (-2) - 1)。

2、取模：

取模的行为与取余类似，但关键的区别在于它是如何处理负数的。Math.floorMod 的工作原理是：在执行除法时，
商，会向下取整到最接近的整数。

例如，对于 Math.floorMod(-7, 3)，结果是 2。为什么？

这里的关键是“向下取整”。当我们将-7除以3时，商是-2.33。向下取整意味着向负无穷方向取整，所以商是-3。余数是2，
因为 (-7 = 3 × (-3) + 2)。

这种区别主要是如何处理商的小数部分。在取余操作中，我们只是简单地丢弃小数部分，所以-7除以3的商是-2。而在取模操作中，
我们向下取整，所以-7除以3的商是-3。

3、 位与运算
已知length = 2的n次方。
`hash % length = hash % 2n`，在二进制中结果就是hash的最低n位的值。因为在对2的n次方取余的操作中，高于2的n次方
表示位的所有数值对结果没有贡献，只有低于这个阈值的部分才决定余数。
当执行hash & (length - 1)时，实际上是保留 hash 二进制表示的最低 n 位，其他高位都被清零。
即 `hash % lenght = hash & (length - 1)`。
运算`hash & (length - 1)`就是将hash的高位全部归零，指保留低位值。
HashMap中在存取元素的时候会根据key优化后的hash值和数组的长度进行取模运算，其形式为 hash & (n -1)

# 2 HashMap
## 2.1 hash方法的原理
在调用HashMap#put(K, V)的时候，会首先调用hash(K)。

hash方法的实现思路是先获取对象key的HashCode的值，将HashCode的值二进制数右移16位得到新的二进制数，然后和原
HashCode的值进行异或运算，得到新的hash值。混合了原hash值的高位和地位，增加了随机线性，让元素能均匀地分布，
减少碰撞。

为什么要进行异或运算，因为对于HashCode的高位和低位的分布是比较均匀的，如果只是进行简单的将它们加起来或者进行
位运算，容易出现哈希冲突，而异或运算可以避免这个问题。

然后将得到和hash值与HashMap中table的长度 -1 进行取模运算，得到键值对在数组中的索引。

哈希表是基于数组的，每个数组元素是一个桶，桶中存储了键值对。 在JDK8中，桶的底层是链表或者红黑树实现的。HashMap
通过拉链法解决冲突问题。

对于int类型的数a和b，如果b是2的n次方，则有如下的规律：
a%b = a&(b-1)



## 2.2 HashMap的扩容机制
### 2.2.1 jdk 7 和 jdk 8的不同
扩容的过程中，会重新散列元素，针对元素在数组中的索引，jdk 7 会重新计算hash值，而jdk 8不会重新计算hash。
jdk 7 采用了单链表头部插入的方式拷贝元素，即同一个桶新放置的元素位于链表的头部，这样改变了元素在旧数组同一个链表
上元素的顺序；jdk 8 则不是，jdk 8 定义了一个head，记录了旧数组中链表的头部元素，
且该元素的链表保证了原数组同一个链表中元素的顺序。

在添加元素的时候，如果元素发生了hash碰撞，jdk 7 上桶是以链表结构实现的，而jdk 8，桶的链表如果元素个数超过了8个，
则桶的链表结构转化为红黑树。

### 2.2.2 小结
HashMap的内部是通过一个数组和链表或红黑树的组合实现的。当向HashMap中不断添加元素时，如果元素的数量达到元素数量
的阈值（数组容量乘以负载因子），就会自动将数组扩容，扩容的大小为原来的两倍，然后将旧数组中的桶中的元素节点重新散列到
新数组中。 下面是HashMap的扩容原理：
    
1. 遍历旧数组中的元素。如果指定索引的元素不在链表和二叉树上，那么根据元素节点的hash计算在新数组中的索引，新数组
该索引的引用指向该元素节点；如果指定索引的元素在二叉树上，那么将该索引的树桶拆分成低位树桶和高位树桶，或者低位链表桶
和高位链表桶；如果指定索引的元素在链表上，那么将该索引桶拆分成低位链表桶和高位链表桶。
2. 如果指定索引的元素在链表上，散列的原理是：临时构造一个低位链表，一个高位链表，根据节点的hash和旧数组的容量进行
位于运算，如果结果为0，则节点在低位链表中，否则节点在高位链表中；节点在新数组中的索引要么是旧数组中的索引，要么是
旧数组中的索引加旧数组的容量；根据低位高位链表的头节点和尾节点来赋值新数组指定索引的引用。
3. 如果指定索引的元素在二叉树上，那么将该索引的树桶拆分成低位树桶和高位树桶，或者低位链表桶和高位链表桶，散列的原理是；
将当前树桶中所有节点，根据哈希值和旧数组的容量进行位与运算，进行分组，形成低位/高位两个集合（lo / hi）：
+ 低位 lo：hash & bit == 0
+ 高位 hi：hash & bit != 0
拆分后判断两边节点数量：如果数量大于等于阈值（默认 6），保留树结构；否则将树退化成链表结构。

## 2.3 加载因子为什么是0.75
`加载因子 = 元素数量 / 数组容量`表示HashMap中元素的填满程度。
+ 如果负载因子过大，填充程度大，出现较多的元素存储在较少的桶中，导致了冲突的增加，导致插入、删除、查找的效率降低；
数组容量小，会导致频繁低扩容，进一步降低了效率。
+ 如果负载因子过小，填充程度小，出现较少的元素存储在较多的桶中，虽然减小了冲突，但是桶的空间利用率变小了，空间上开销大。
0.75是平衡了时间和空间上的消耗，保证了哈希表的性能表现和空间利用率。

## 2.4 线程不安全
HashMap不是线程安全的，主要有两方面的原因：
+ put操作可能会导致数据丢失。
+ put和get并发导致get得到的是null。

# 3 LinkedHashMap
LinkedHashMap继承HashMap。
## 3.1 插入顺序
LinkedHashMap中定义了head和tail两个字段，并且它的元素节点定义了before（前驱节点）和after（后继节点）
两个字段，通过这四个字段构成了一个双向链表，用来维护元素的插入顺序。当向LinkedHashMap中插入元素时，会将该元素
节点放到链表的尾部，如果是第一个元素，则设置head为该节点。
## 3.2 访问顺序
LinkedHashMap不仅能维持插入顺序，还能够维持访问顺序。访问包括`get`、`put`、`remove`。要维护访问顺序，
需要在构造LinkedHashMap的时候，`accessOrder`需要为`true`。
## 3.3 小节
LinkedHashMap继承HashMap，它在HashMap的基础上，增加了一个双向链表来维护元素的插入顺序或访问顺序。链表的头
节点表示最早插入或访问的元素，尾节点是最晚插入或访问的元素。当向LinkedHashMap中插入元素时，会将该元素
节点放到链表的尾部，如果是第一个元素，则设置head为该元素。如果`accessOrder`为`true`，当访问其中的元素时，
会将访问的元素节点移动到链表的尾部。
// TODO LinkedList https://javabetter.cn/collection/linkedlist.html